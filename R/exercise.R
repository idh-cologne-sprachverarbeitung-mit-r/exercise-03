h0 <- c(0.763226370327175, 0.952643654774874, 0.378943434683606, 0.0164877194911242, 
0.0241197412833571, 0.696068192832172, 0.771423062775284, 0.914415687322617, 
0.212928134249523, 0.320050833979622, 0.0157103042583913, 0.504266540519893, 
0.519695297349244, 0.46969918650575, 0.231218204135075, 0.0512986921239644, 
0.0813010225538164, 0.108353753341362, 0.0397423240356147, 0.493777783354744, 
0.751715533202514, 0.364607897819951, 0.796813463326544, 0.568875040858984, 
0.892567021772265, 0.660698340972885, 0.440083057619631, 0.585455034859478, 
0.22910659504123, 0.0602104812860489, 0.0340489267837256, 0.871861131628975, 
0.981888954760507, 0.430191747611389, 0.836929353419691, 0.462224684190005, 
0.381377515848726, 0.826874321093783, 0.220546001335606, 0.422653938876465, 
0.658919757464901, 0.195541890803725, 0.731190218357369, 0.243826987221837, 
0.311324450653046, 0.423526905244216, 0.159473720705137, 0.734113158890978, 
0.523119577672333, 0.240374732529745, 0.188805905869231, 0.2913108963985, 
0.83534966618754, 0.512532285414636, 0.89641114580445, 0.642676115734503, 
0.114114161580801, 0.752496520755813, 0.781578973866999, 0.717645956901833, 
0.259947627549991, 0.66511160810478, 0.976237760623917, 0.22847018064931, 
0.639559071743861, 0.194496495416388, 0.429573090746999, 0.65584632428363, 
0.86828416865319, 0.327741613145918, 0.993593337712809, 0.927917364286259, 
0.464630534872413, 0.744500288972631, 0.470841593574733, 0.59344006376341, 
0.499884113436565, 0.184636301128194, 0.63452499662526, 0.208259160863236, 
0.498312685173005, 0.398327276809141, 0.964247205527499, 0.0923032788559794, 
0.297006229171529, 0.623674557544291, 0.240658762631938, 0.0329930982552469, 
0.839809884084389, 0.551455266773701, 0.935782446758822, 0.840460516046733, 
0.727259814506397, 0.283441427862272, 0.199344577966258, 0.483388318214566, 
0.986643178621307, 0.997125167865306, 0.133521297946572, 0.408241145079955)


i0 <- c("Kölsch","ist","ein","helles",",","blankes","(","gefiltertes",")","und","obergäriges","Vollbier","mit","einer","durchschnittlichen","Stammwürze","von","11,3","°P","und","einem","Alkoholgehalt","von","durchschnittlich","4,8","%",".")

i1 <- c("N","V","D","A",".","A",".","A",".","K","A","N","P","D","A","N","P","C","N","K","D","N","P","A","C","N",".")

# Assignments

a <- 1:100

b <- mode(a)

c <- as.character(a)

d <- mode(b)

e <- "Oh sphinx of black quartz judge my vow"

# f) A string literal like above implicitly creates a character vector with one
# element, whereas `length` returns the length of the vector, not of the sole
# element in it. One can show that "foo" returns a vector of length 1 via
# `c("foo") == "foo"`

# g) Casting my sentence above will return a vector of length 1 containing a
# "missing value" (`is.na(x) == TRUE`) as the sole element can't be parsed as a
# numeric value. A character vector like `c("42", "23")` would return `c(42, # 23)`

g <- as.numeric(e)

# h)To be honest I'm not sure what I'm supposed to do in this exercise. Converting
# h0 to a character vector works out fine, but converting it back loses
# precision for all numbers (`as.numeric(as.character(h0))`). That vector is
# also equal to `h0`, which indicates that R is somehow downgrading the
# precision of `h0` in equality comparisons.

# The test suite tells me that only seven numbers are expected to make the
# roundtrip without loss (I guess floating point issues?), but I'm at a loss on
# how to create such a vector on my machine.

# i)
i2 <- nchar(i0)
i3 <- factor(i1)
i <- tapply(i2, i3, mean)

k <- mode(i)
